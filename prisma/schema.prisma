// OpenIDB - PostgreSQL Schema
// Source-of-truth database for Islamic texts: books, Quran, hadith

generator client {
  provider = "prisma-client-js"
  output   = "../node_modules/.prisma/client"
}

datasource db {
  provider = "postgresql"
}

// ============================================================================
// CORE ENTITIES
// ============================================================================

model Author {
  id        String   @id @map("id")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Names
  nameArabic String  @map("name_arabic")
  nameLatin  String? @map("name_latin")
  kunya      String? // e.g., "أبو الفرج"
  nasab      String? // Genealogy
  nisba      String? // Place/tribe attribution
  laqab      String? // Title/epithet

  // Dates
  birthDateHijri     String? @map("birth_date_hijri")
  deathDateHijri     String? @map("death_date_hijri")
  birthDateGregorian String? @map("birth_date_gregorian")
  deathDateGregorian String? @map("death_date_gregorian")

  // Biography
  biography       String? @db.Text
  biographySource String? @map("biography_source")

  // Relationships
  books      Book[]
  otherWorks AuthorWork[]

  @@map("authors")
}

model Category {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  code String? @unique @map("code")

  // Names
  nameArabic  String  @unique @map("name_arabic")
  nameEnglish String? @map("name_english")

  // Hierarchy
  parentId Int?       @map("parent_id")
  parent   Category?  @relation("CategoryHierarchy", fields: [parentId], references: [id])
  children Category[] @relation("CategoryHierarchy")

  // Relationships
  books Book[]

  @@index([parentId])
  @@map("categories")
}

model Publisher {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  name     String  @unique @map("name")
  location String? @map("location")

  // Relationships
  books Book[]

  @@map("publishers")
}

model Editor {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  name String @unique @map("name")

  // Relationships
  books Book[]

  @@map("editors")
}

model Book {
  id        String   @id @map("id")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Titles
  titleArabic String  @map("title_arabic")
  titleLatin  String? @map("title_latin")

  // Author Relationship
  authorId String @map("author_id")
  author   Author @relation(fields: [authorId], references: [id], onDelete: Restrict)

  // Category Relationship
  categoryId Int?      @map("category_id")
  category   Category? @relation(fields: [categoryId], references: [id])

  // Publisher Relationship
  publisherId Int?       @map("publisher_id")
  publisher   Publisher? @relation(fields: [publisherId], references: [id])

  // Editor Relationship
  editorId Int?    @map("editor_id")
  editor   Editor? @relation(fields: [editorId], references: [id])

  // Publication Information
  publicationYearHijri     String? @map("publication_year_hijri")
  publicationYearGregorian String? @map("publication_year_gregorian")
  publicationEdition       String? @map("publication_edition")
  publicationLocation      String? @map("publication_location")
  isbn                     String?

  // Structure
  totalVolumes      Int     @default(1) @map("total_volumes")
  totalPages        Int?    @map("total_pages")
  pageAlignmentNote String? @map("page_alignment_note") // "موافق للمطبوع"

  // Editorial Information
  verificationStatus String? @map("verification_status") // "محقق" or "غير محقق"
  editorialType      String? @map("editorial_type") // "رسالة ماجستير", "رسالة دكتوراه", "بحث"
  institution        String? // University
  supervisor         String?

  // Content
  descriptionHtml String? @map("description_html") @db.Text
  summary         String? @db.Text
  tableOfContents Json?   @map("table_of_contents") // [{title, level, page}]

  // File Reference
  filename String // EPUB filename

  // Time Period (for filtering/grouping)
  timePeriod String? @map("time_period")

  // Relationships
  keywords          BookKeyword[]
  pages             Page[]
  titleTranslations BookTitleTranslation[]

  @@index([authorId])
  @@index([categoryId])
  @@map("books")
}

// ============================================================================
// JUNCTION TABLES
// ============================================================================

model BookKeyword {
  bookId  String @map("book_id")
  keyword String

  book Book @relation(fields: [bookId], references: [id], onDelete: Cascade)

  @@id([bookId, keyword])
  @@map("book_keywords")
}

model AuthorWork {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now()) @map("created_at")

  authorId    String  @map("author_id")
  bookId      String  @map("book_id")
  title       String
  isInCatalog Boolean @default(false) @map("is_in_catalog")

  author Author @relation(fields: [authorId], references: [id], onDelete: Cascade)

  @@index([authorId])
  @@index([bookId])
  @@map("author_works")
}

// ============================================================================
// CONTENT TABLES
// ============================================================================

model Page {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now()) @map("created_at")

  bookId       String @map("book_id")
  pageNumber   Int    @map("page_number") // Sequential page number
  volumeNumber Int    @default(1) @map("volume_number")

  // Page Identification
  urlPageIndex      String? @map("url_page_index") // Could be 'i' for overview, or integer
  printedPageNumber Int?    @map("printed_page_number") // Page number as printed in book

  // Content
  contentPlain String  @map("content_plain") @db.Text
  contentHtml  String  @map("content_html") @db.Text
  contentHash  String? @map("content_hash")

  // Formatting Hints
  hasPoetry   Boolean @default(false) @map("has_poetry")
  hasHadith   Boolean @default(false) @map("has_hadith")
  hasQuran    Boolean @default(false) @map("has_quran")
  hasDialogue Boolean @default(false) @map("has_dialogue")

  // References
  sourceUrl String? @map("source_url")
  pdfUrl    String? @map("pdf_url")

  // Relationships
  book         Book              @relation(fields: [bookId], references: [id], onDelete: Cascade)
  translations PageTranslation[]

  @@unique([bookId, pageNumber])
  @@index([bookId, pageNumber])
  @@map("pages")
}

// ============================================================================
// TRANSLATION TABLES
// ============================================================================

model BookTitleTranslation {
  id       Int    @id @default(autoincrement())
  bookId   String @map("book_id")
  language String // "en", "fr", "id", etc.
  title    String @db.Text

  book Book @relation(fields: [bookId], references: [id], onDelete: Cascade)

  @@unique([bookId, language])
  @@index([bookId])
  @@index([language])
  @@map("book_title_translations")
}

model PageTranslation {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  pageId      Int     @map("page_id")
  language    String // "en", "fr", "id", "ur", etc.
  model       String // "gemini-flash", "gpt-oss-120b" - stored for reference but not part of unique key
  paragraphs  Json // [{index: 0, translation: "..."}, ...]
  contentHash String? @map("content_hash")

  page Page @relation(fields: [pageId], references: [id], onDelete: Cascade)

  @@unique([pageId, language])
  @@index([pageId])
  @@map("page_translations")
}

// ============================================================================
// QURAN - Separate from books system
// ============================================================================

model Surah {
  id             Int    @id @default(autoincrement())
  number         Int    @unique
  nameArabic     String @map("name_arabic")
  nameEnglish    String @map("name_english")
  revelationType String @map("revelation_type") // "Meccan" | "Medinan"
  ayahCount      Int    @map("ayah_count")

  ayahs Ayah[]

  @@map("surahs")
}

model Ayah {
  id          Int     @id @default(autoincrement())
  surahId     Int     @map("surah_id")
  ayahNumber  Int     @map("ayah_number")
  textUthmani String  @map("text_uthmani") @db.Text
  textPlain   String  @map("text_plain") @db.Text // For search
  contentHash String? @map("content_hash")
  juzNumber   Int     @map("juz_number")
  pageNumber  Int     @map("page_number") // Standard mushaf page

  surah Surah @relation(fields: [surahId], references: [id])

  @@unique([surahId, ayahNumber])
  @@index([surahId])
  @@map("ayahs")
}

model AyahTranslation {
  id          Int     @id @default(autoincrement())
  surahNumber Int     @map("surah_number")
  ayahNumber  Int     @map("ayah_number")
  language    String // "en", "ur", "fr", "id", etc.
  editionId   String  @map("edition_id") // "eng-mustafakhattaba", etc.
  text        String  @db.Text
  contentHash String? @map("content_hash")

  @@unique([surahNumber, ayahNumber, editionId])
  @@index([surahNumber, ayahNumber])
  @@index([language])
  @@index([editionId])
  @@map("ayah_translations")
}

model AyahTafsir {
  id          Int     @id @default(autoincrement())
  surahNumber Int     @map("surah_number")
  ayahNumber  Int     @map("ayah_number")
  source      String // "jalalayn", "ibn_kathir", etc. (kept for backward compat)
  editionId   String  @map("edition_id") // "ar-tafsir-ibn-kathir", "ar-jalalayn"
  language    String  @default("ar") // "ar", "en", "bn", etc.
  text        String  @db.Text
  contentHash String? @map("content_hash")

  @@unique([surahNumber, ayahNumber, editionId])
  @@index([surahNumber, ayahNumber])
  @@index([source])
  @@index([editionId])
  @@index([language])
  @@map("ayah_tafsirs")
}

model QuranTranslation {
  id        String  @id // "eng-mustafakhattaba"
  language  String // ISO code: "en", "ar", etc.
  name      String // Display name
  author    String? // Translator name
  source    String // "fawazahmed0"
  direction String  @default("ltr") // "ltr" | "rtl"

  @@index([language])
  @@map("quran_translations")
}

model QuranTafsir {
  id        String  @id // "ar-tafsir-ibn-kathir"
  language  String // ISO code: "en", "ar", etc.
  name      String // Display name
  author    String? // Author name
  source    String // "spa5k-tafsir"
  direction String  @default("ltr") // "ltr" | "rtl"

  @@index([language])
  @@map("quran_tafsirs")
}

model QuranReciter {
  id          Int     @id @default(autoincrement())
  slug        String  @unique              // "everyayah/alafasy-128kbps", "alquran-cloud/ar.alafasy"
  nameArabic  String? @map("name_arabic")
  nameEnglish String  @map("name_english") // "Mishary Rashid Alafasy"
  style       String?                      // "Murattal", "Mujawwad", null
  qiraat      String  @default("hafs")     // "hafs", "warsh"
  bitrate     Int     @default(128)        // kbps of stored files
  totalAyahs  Int     @default(0) @map("total_ayahs") // 0-6236
  source      String                       // "everyayah", "alquran-cloud", "quran-foundation"
  sourceUrl   String? @map("source_url")   // upstream base URL for attribution
  language    String  @default("ar")       // "ar", "en", "ur", etc.
  sizeBytes   BigInt  @default(0) @map("size_bytes")

  @@index([qiraat])
  @@index([language])
  @@map("quran_reciters")
}

// ============================================================================
// HADITH - Sunnah.com integration
// ============================================================================

model HadithCollection {
  id          Int    @id @default(autoincrement())
  slug        String @unique // "bukhari", "muslim", etc.
  nameEnglish String @map("name_english")
  nameArabic  String @map("name_arabic")

  books HadithBook[]

  @@map("hadith_collections")
}

model HadithBook {
  id           Int    @id @default(autoincrement())
  collectionId Int    @map("collection_id")
  bookNumber   Int    @map("book_number")
  nameEnglish  String @map("name_english")
  nameArabic   String @map("name_arabic")

  collection HadithCollection @relation(fields: [collectionId], references: [id])
  hadiths    Hadith[]

  @@unique([collectionId, bookNumber])
  @@index([collectionId])
  @@map("hadith_books")
}

model Hadith {
  id               Int     @id @default(autoincrement())
  bookId           Int     @map("book_id")
  hadithNumber     String  @map("hadith_number") // String for variants like "8a"
  textArabic       String  @map("text_arabic") @db.Text
  textPlain        String  @map("text_plain") @db.Text // Diacritics removed for search
  contentHash      String? @map("content_hash")
  chapterArabic    String? @map("chapter_arabic")
  chapterEnglish   String? @map("chapter_english")
  isChainVariation Boolean @default(false) @map("is_chain_variation") // True for hadiths that are only chain variations (no matn)
  source           String?                                             // Data provenance: "sunnah.com", "hadithunlocked.com"

  // Isnad/Matn separation (from hadithunlocked.com)
  isnad     String? @db.Text // Chain of narrators (Arabic, with tashkeel)
  matn      String? @db.Text // Hadith body text (Arabic, with tashkeel)
  gradeText String? @map("grade_text") // Full grade description (English, e.g. "Sound - agreed upon")

  // Dorar.net metadata
  dorarId           String?  @unique @map("dorar_id")
  narratorName      String?  @map("narrator_name")        // الراوي
  grade             String?                                // صحيح، حسن، ضعيف
  gradeExplanation  String?  @map("grade_explanation") @db.Text  // تفصيل الحكم
  graderName        String?  @map("grader_name")           // المحدث (الألباني، إلخ)
  graderDorarId     Int?     @map("grader_dorar_id")       // Dorar scholar ID
  sourceBookName    String?  @map("source_book_name")      // المصدر (اسم الكتاب الأصلي)
  sourceBookDorarId Int?     @map("source_book_dorar_id")  // Dorar book ID
  numberOrPage      String?  @map("number_or_page")        // الصفحة أو الرقم
  takhrij           String?  @db.Text                      // التخريج
  categories        Json?                                  // [{id, name}] topic classifications
  hasSimilar        Boolean? @default(false) @map("has_similar")
  hasAlternate      Boolean? @default(false) @map("has_alternate")
  hasUsul           Boolean? @default(false) @map("has_usul")
  sharhText         String?  @map("sharh_text") @db.Text   // Commentary text
  usulData          Json?    @map("usul_data")             // Transmission chains [{source, chain, hadithText}]

  book HadithBook @relation(fields: [bookId], references: [id])

  @@unique([bookId, hadithNumber])
  @@index([bookId])
  @@index([dorarId])
  @@map("hadiths")
}

model HadithTranslation {
  id           Int     @id @default(autoincrement())
  bookId       Int     @map("book_id")
  hadithNumber String  @map("hadith_number")
  language     String // "en" for now, expandable later
  text         String  @db.Text
  contentHash  String? @map("content_hash")

  @@unique([bookId, hadithNumber, language])
  @@index([bookId, hadithNumber])
  @@index([language])
  @@map("hadith_translations")
}

// ============================================================================
// DICTIONARY
// ============================================================================

model DictionarySource {
  id          Int      @id @default(autoincrement())
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")
  slug        String   @unique                          // "lisan-al-arab"
  nameArabic  String   @map("name_arabic")              // "لسان العرب"
  nameEnglish String   @map("name_english")             // "Lisan al-Arab"
  author      String?
  bookId      String?  @map("book_id")                  // "1687"
  description String?  @db.Text

  entries    DictionaryEntry[]
  subEntries DictionarySubEntry[]

  @@map("dictionary_sources")
}

model DictionaryEntry {
  id                 Int      @id @default(autoincrement())
  createdAt          DateTime @default(now()) @map("created_at")
  sourceId           Int      @map("source_id")
  root               String   @db.Text
  rootNormalized     String   @map("root_normalized") @db.Text
  headword           String   @db.Text
  headwordNormalized String   @map("headword_normalized") @db.Text
  headwordVocalized  String   @default("") @map("headword_vocalized") @db.Text
  definitionHtml     String   @map("definition_html") @db.Text
  definitionPlain    String   @map("definition_plain") @db.Text
  contentHash        String?  @map("content_hash")
  bookId             String?  @map("book_id")
  startPage          Int?     @map("start_page")
  endPage            Int?     @map("end_page")

  source     DictionarySource   @relation(fields: [sourceId], references: [id], onDelete: Cascade)
  subEntries DictionarySubEntry[]

  @@index([sourceId])
  @@index([rootNormalized])
  @@index([headwordNormalized])
  @@index([headwordVocalized])
  @@map("dictionary_entries")
}

model DictionarySubEntry {
  id                 Int      @id @default(autoincrement())
  createdAt          DateTime @default(now()) @map("created_at")
  entryId            Int?     @map("entry_id")
  sourceId           Int      @map("source_id")
  headword           String   @db.Text           // "الْحُرُّ" (vocalized)
  headwordNormalized String   @map("headword_normalized") @db.Text
  headwordVocalized  String   @default("") @map("headword_vocalized") @db.Text
  root               String   @db.Text
  rootNormalized     String   @map("root_normalized") @db.Text
  definitionHtml     String   @map("definition_html") @db.Text
  definitionPlain    String   @map("definition_plain") @db.Text
  position           Int      @default(0)
  bookId             String?  @map("book_id")
  pageNumber         Int?     @map("page_number")

  entry  DictionaryEntry?  @relation(fields: [entryId], references: [id], onDelete: SetNull)
  source DictionarySource @relation(fields: [sourceId], references: [id], onDelete: Cascade)

  @@index([sourceId])
  @@index([entryId])
  @@index([headwordNormalized])
  @@index([headwordVocalized])
  @@index([rootNormalized])
  @@index([bookId, pageNumber])
  @@map("dictionary_sub_entries")
}

model ArabicRoot {
  id           Int     @id @default(autoincrement())
  word         String  @db.Text   // normalized surface form: "كتاب"
  root         String  @db.Text   // 3-letter root: "كتب"
  vocalized    String? @db.Text   // vocalized form: "كَاتِبٌ"
  pattern      String? @db.Text   // wazn pattern: "فَاعِلٌ"
  wordType     String? @map("word_type")  // e.g., "اسم فاعل", "مصدر"
  definition   String? @db.Text
  partOfSpeech String? @map("part_of_speech") // "noun" | "verb"
  source       String? @db.VarChar(30) // "arramooz" | "taj-derivatives" | "dictionary" | "generated"

  @@unique([word, root])
  @@index([word])
  @@index([root])
  @@map("arabic_roots")
}

// ============================================================================
// SEARCH ANALYTICS
// ============================================================================

/// Search analytics for embedding model training and diagnostics.
/// 1 row per search query. topResults stores ranked results as compact JSON.
model SearchEvent {
  id          String   @id @default(uuid())
  sessionId   String?  @map("session_id")
  query       String
  mode        String   // "hybrid" | "semantic" | "keyword"
  isRefine    Boolean  @default(false) @map("is_refine")
  resultCount Int      @default(0) @map("result_count")
  totalTimeMs Int?     @map("total_time_ms")
  topResults  Json?    @map("top_results") // [{t,d,s,r}] — type, docId, score, rank (top 20)
  createdAt   DateTime @default(now()) @map("created_at")

  clicks SearchClick[]

  @@index([createdAt])
  @@index([sessionId])
  @@map("search_events")
}

/// A user click on a search result. Primary positive relevance signal
/// for contrastive embedding training: (query, clicked_doc) = positive pair.
model SearchClick {
  id            String      @id @default(uuid())
  searchEventId String      @map("search_event_id")
  searchEvent   SearchEvent @relation(fields: [searchEventId], references: [id], onDelete: Cascade)
  resultType    String      @map("result_type") // "book" | "quran" | "hadith"
  docId         String      @map("doc_id")      // "{bookId}:{page}", "{surah}:{ayah}", "{collection}:{number}"
  rank          Int         // position clicked (1-based)
  createdAt     DateTime    @default(now()) @map("created_at")

  @@index([searchEventId])
  @@map("search_clicks")
}

/// Book reader interaction events for usage analytics.
/// Single table: each row = one user action (open, page_view, pdf_open, word_lookup).
model BookEvent {
  id         String   @id @default(uuid())
  sessionId  String?  @map("session_id")
  bookId     String   @map("book_id")
  action     String   // "open" | "page_view" | "pdf_open" | "word_lookup"
  pageNumber Int?     @map("page_number")
  durationMs Int?     @map("duration_ms")  // time on page (page_view only)
  word       String?                       // looked-up word (word_lookup only)
  createdAt  DateTime @default(now()) @map("created_at")

  @@index([createdAt])
  @@index([sessionId])
  @@index([bookId])
  @@map("book_events")
}
